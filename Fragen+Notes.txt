Fragen:

- sollte es alle Methoden, wo man den Namen direkt setzen kann auch ohne Namen geben? (passive resource, assembly context etc.)
- SetVariableAction: was ist die Voraussetzung?
- ResourceTimoutFailureType vs Passive Resource: wo wird was gesetzt?


ToDo:
- fetch of imported components: name mit Punkt: mediastore.Database
- validation vom repository -> Yves fragt nach
- Sichtbarkeit
- Reihenfolge mit Interfaces regeln: required characterisation geht nicht vor signature; manche Sachen dürfen nur einmal aufgerufen werden


Nutzer: anonymous; PW: anonymous;


Vortrag und Ausarbeitung
- 7.9. 9-12 MS Teams
- 11:30-11:50 Louisa 20min Präsentation 15min; Ziel motivation, was gemacht, Sprachdesign, Beispiel-minimum Elemente eingehe: repos;
- ARE Vorlagen
- Readme statt Ausarbeitung: Beschreibung; was braucht man zum selbst bauen, abhängigkeit, wie benutzen


Notizen

Wo werden Parameter erstellt?
- signaturen: OperationSignature, infrastructureSignature, EventType, resourceSignature -> Parameter erstellen
- collection iteration action -> fetch
- required characterisation -> fetch

Wo werden Variable Usages erstellt?
- GeneralAction: resource call + infrastructure call
- andere Actions: SetVariableAction, ForkAction, ExternalCallAction
- components

- sinnvoll über Factory zu erstellen: components, interfaces, data types/failure/exception types, seffs
- TextBasedModelGenerator nicht alles umgesetzt -> die hier verwendet sind, sind wichtig
- erst die Seffs anschauen
- Infrastructure and Resource Sachen zuletzt anschauen (Resource Interface)
- exception types erst mal ignorieren
- keine Passiv-Relationen erstellen
- interface Protocols ignorieren
- access über fetch methoden; nicht nur String, damit weniger Magie
- nicht immer direkt einen Namen verlangen -> TODO: wird das eingehalten
- seffs haben keinen Namen


Durch die verschiedenen Referenzen: kann es zu Inkonsistenzen kommen, wenn mehrfach der gleiche Creator gebuilded wird, aber womöglich zwischendurch Änderungen entstehen -> es soll immer das gleiche Objekt bei rauskommen
=> vielleicht, wenn Build methode aufgerufen wird ein palladio objekt im creator objekt erstellen, dass dann referenziert/aktualisiert wird? Herausfinden, welche Dinge sich überhaupt ändern können nachdem sie referenziert wurden. Gibt es co-abhängigkeiten?


Das muss über die Factory abrufbar sein:
- Components, Interfaces, DataTypes
- Assembly Contexts, Roles
- Parameters



Factorys:

- AllocationFactory: Allocation + Allocation Context
- AllocationAdapterFactory
														- CompositionFactory: Connectors + Event Channel
														- CoreFactory: PCM Random Variable
- CoreAdapterFactory
- CoreResourceFactory
														- EntityFactory: Resource provided role, resource interface
- EntityAdapterFactory
- EntityResourceFactory
														- ParameterFactory: VariableCharacterisation, Variable usage, characterised variable
- ParameterAdapterFactory
- ParameterResourceFactory
- PcmFactory
- PcmAdapterFactory
- PcmResourceFactory
- ProtocolFactory
- ProtocolAdapterFactory
- ProtocolResourceFactory
- QosAnnotationsFactory: QoSAnnotations
														- ReliabilityFactory: Failure Types
- ReliabilityAdapterFactory
														- RepositoryFactory: Components etc.
- RepositoryAdapterFactory
- ResourcetypeFactory: resource interface, repo, signature, communication link, scheduling policy
														- SeffFactory: Seff Kram
- SeffAdapterFactory
- SeffResourceFactory
	- SeffReliabilityFactory: Recovery action
														- SubsystemFactory
- SubsystemAdapterFactory
- SubsystemResourceFactory
- SystemFactory: System
- SystemAdapterFactory
- SystemResourceFactory
- UsagemodelFactory
- UsagemodelAdapterFactory: Branch, delay, loop






Done:
- Composite + collection data types
- roles

